generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}
 
model User {
  id        String   @id @default(cuid())
  uid       String   @unique @default(uuid())
  name      String
  email     String   @unique
  phone     String?
  password  String
  role      String   @default("USER")
  status    String   @default("ACTIVE")
  createdAt DateTime @default(now())
}

model Cinema {
  id        String @id @default(cuid())
  name      String
  region    String
  address   String
  latitude  Float?
  longitude Float?
  logoUrl   String?
  phone     String?
}

model Movie {
  id          String   @id @default(cuid())
  title       String
  actors      String?
  duration    Int
  genres      String?
  releaseDate DateTime?
  rating      Float?
  description String?
  posterUrl   String?
}

model Screening {
  id        String   @id @default(cuid())
  movieId   String
  cinemaId  String
  room      String
  startTime DateTime
  endTime   DateTime
  price     Int
  seats     Seat[]
  seatStatuses SeatStatus[]
  orders    Order[]
}

model Review {
  id        String   @id @default(cuid())
  movieId   String
  userId    String
  rating    Int
  content   String?
  tags      String?
  createdAt DateTime @default(now())
}

enum SeatState {
  AVAILABLE
  HELD
  SOLD
}

model Seat {
  id          String    @id @default(cuid())
  screeningId String
  row         Int
  col         Int
  code        String    // "A1", "D6", ...
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  screening   Screening @relation(fields: [screeningId], references: [id], onDelete: Cascade)
  statuses    SeatStatus[]

  @@unique([screeningId, row, col])
  @@index([screeningId])
}

model SeatStatus {
  id          String    @id @default(cuid())
  seatId      String
  screeningId String
  status      SeatState @default(AVAILABLE)
  holdToken   String?
  holdUserId  String?
  holdUntil   DateTime?
  orderId     String?
  createdAt   DateTime  @default(now())
  seat        Seat      @relation(fields: [seatId], references: [id], onDelete: Cascade)
  screening   Screening @relation(fields: [screeningId], references: [id], onDelete: Cascade)
  order       Order?    @relation(fields: [orderId], references: [id], onDelete: SetNull)
  
  @@index([screeningId, seatId])
  @@index([screeningId, status])
  @@index([holdToken])
  @@index([seatId, createdAt])
}

model Order {
  id              String    @id @default(cuid())
  userId          String
  screeningId     String
  holdToken       String    @unique
  status          String    @default("PENDING")
  seatIds         String
  pricingBreakdown String?
  totalAmount     Int
  voucherCode     String?
  idempotencyKey  String?   @unique
  expiresAt       DateTime
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  screening       Screening @relation(fields: [screeningId], references: [id], onDelete: Cascade)
  seatStatuses    SeatStatus[]
  payments        Payment[]
  tickets         Ticket[]

  @@index([userId])
  @@index([holdToken])
  @@index([status, expiresAt])
}

model Ticket {
  id         String    @id @default(cuid())
  code       String    @unique @default(uuid())
  orderId    String
  screeningId String
  seatId     String
  seatRow    Int
  seatCol    Int
  userId     String
  status     String    @default("PENDING")
  price      Int
  qrCode     String?
  checkInAt  DateTime?
  createdAt  DateTime  @default(now())
  order      Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model Payment {
  id         String    @id @default(cuid())
  orderId    String
  ticketId   String?
  amount     Int
  method     String
  status     String    @default("PENDING")
  externalRef String?
  redirectUrl String?
  webhookData String?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  order      Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
}
